'use client';\n\nimport { useState, useCallback, useRef } from 'react';\n\nexport function useAudio() {\n  const [isRecording, setIsRecording] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [audioUrl, setAudioUrl] = useState('');\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [error, setError] = useState(null);\n  \n  const mediaRecorderRef = useRef(null);\n  const audioRef = useRef(null);\n  const timerRef = useRef(null);\n\n  const startRecording = useCallback(async () => {\n    try {\n      setError(null);\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n      const chunks = [];\n      \n      mediaRecorder.ondataavailable = (event) => {\n        chunks.push(event.data);\n      };\n      \n      mediaRecorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/webm' });\n        const url = URL.createObjectURL(blob);\n        setAudioBlob(blob);\n        setAudioUrl(url);\n        \n        // Stop all tracks\n        stream.getTracks().forEach(track => track.stop());\n      };\n      \n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.start();\n      setIsRecording(true);\n      setRecordingTime(0);\n      \n      // Start timer\n      timerRef.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n      \n    } catch (err) {\n      console.error('Error accessing microphone:', err);\n      setError('Không thể truy cập microphone. Vui lòng kiểm tra quyền truy cập.');\n    }\n  }, []);\n  \n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n      \n      if (timerRef.current) {\n        clearInterval(timerRef.current);\n      }\n    }\n  }, [isRecording]);\n  \n  const playAudio = useCallback(() => {\n    if (audioRef.current && audioUrl) {\n      audioRef.current.src = audioUrl;\n      audioRef.current.play().then(() => {\n        setIsPlaying(true);\n      }).catch(err => {\n        console.error('Error playing audio:', err);\n        setError('Không thể phát audio');\n      });\n    }\n  }, [audioUrl]);\n  \n  const pauseAudio = useCallback(() => {\n    if (audioRef.current) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    }\n  }, []);\n  \n  const stopAudio = useCallback(() => {\n    if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n      setIsPlaying(false);\n    }\n  }, []);\n  \n  const deleteRecording = useCallback(() => {\n    stopAudio();\n    setAudioBlob(null);\n    setAudioUrl('');\n    setRecordingTime(0);\n    setError(null);\n  }, [stopAudio]);\n\n  const formatTime = useCallback((seconds) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  }, []);\n\n  return {\n    isRecording,\n    isPlaying,\n    audioBlob,\n    audioUrl,\n    recordingTime,\n    error,\n    startRecording,\n    stopRecording,\n    playAudio,\n    pauseAudio,\n    stopAudio,\n    deleteRecording,\n    formatTime: () => formatTime(recordingTime),\n    audioRef\n  };\n}"